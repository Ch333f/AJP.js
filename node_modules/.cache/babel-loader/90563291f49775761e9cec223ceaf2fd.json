{"ast":null,"code":"import _defineProperty from \"C:\\\\Users\\\\Mr O\\\\Desktop\\\\devspace\\\\AJP\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Mr O\\\\Desktop\\\\devspace\\\\AJP\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\n/** This function is for create and merge configuration */\nfunction setOptions(config) {\n  var baseConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Create new Config object;\n  var newConfig = {};\n\n  // Loop config items to set it value into newConfig\n  for (var key in config) {\n    // if baseConfig is set, only accept the baseconfig property\n    if (baseConfig !== {} && !baseConfig.hasOwnProperty(key)) continue;\n    // parse the config value\n    var val = parseValue(config[key]);\n    // set the newConfig property value\n    newConfig[key] = val;\n    // Exclusive for 'duration' or 'pulse' property, recheck the value\n    // If it's not a boolean, just set it to milisecond unit\n    if (key.match(/duration|pulse/)) {\n      newConfig[key] = typeof val != \"boolean\" ? val * 1000 : val;\n    }\n  }\n\n  // Finally, we can just merge the baseConfig (if any), with newConfig.\n  return Object.assign({}, baseConfig, newConfig);\n}\n\n/** This is the the counter method */\nfunction startCounter(element, config) {\n  // First, get the increments step\n  var incrementsPerStep = (config.end - config.start) / (config.duration / config.delay);\n  // Next, set the counter mode (Increment or Decrement)\n  var countMode = \"inc\";\n\n  // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n  if (config.start > config.end) {\n    countMode = \"dec\";\n    incrementsPerStep *= -1;\n  }\n\n  // Next, determine the starting value\n  var currentCount = parseValue(config.start);\n  // And then print it's value to the page\n  element.innerHTML = formatNumber(currentCount, config);\n\n  // If the config 'once' is true, then set the 'duration' to 0\n  if (config.once === true) {\n    element.setAttribute(\"data-purecounter-duration\", 0);\n  }\n\n  // Now, start counting with counterWorker using Interval method based on delay\n  var counterWorker = setInterval(function () {\n    // First, determine the next value base on current value, increment value, and count mode\n    var nextNum = nextNumber(currentCount, incrementsPerStep, countMode);\n    // Next, print that value to the page\n    element.innerHTML = formatNumber(nextNum, config);\n    // Now set that value to the current value, because it's already printed\n    currentCount = nextNum;\n\n    // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n    if (currentCount >= config.end && countMode === \"inc\" || currentCount <= config.end && countMode === \"dec\") {\n      element.innerHTML = formatNumber(config.end, config) + \"+\";\n      // If 'pulse' is set ignore the 'once' config\n      if (config.pulse) {\n        // First set the 'duration' to zero\n        element.setAttribute(\"data-purecounter-duration\", 0);\n        // Next, use timeout to reset it duration back based on 'pulse' config\n        setTimeout(function () {\n          element.setAttribute(\"data-purecounter-duration\", config.duration / 1000);\n        }, config.pulse);\n      }\n      clearInterval(counterWorker);\n    }\n  }, config.delay);\n}\n\n/** This function is to get the next number */\nfunction nextNumber(number, steps) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"inc\";\n  // First, get the exact value from the number and step (int or float)\n  number = parseValue(number);\n  steps = parseValue(steps);\n\n  // Last, get the next number based on current number, increment step, and count mode\n  // Always return it as float\n  return parseFloat(mode === \"inc\" ? number + steps : number - steps);\n}\n\n/** This function is to convert number into currency format */\nfunction convertNumber(number, config) {\n  /** Use converter if filesizing or currency is on */\n  if (config.filesizing || config.currency) {\n    number = Math.abs(Number(number)); // Get the absolute value of number\n\n    var baseNumber = 1000,\n      // Base multiplying treshold\n      symbol = config.currency && typeof config.currency === \"string\" ? config.currency : \"\",\n      // Set the Currency Symbol (if any)\n      limit = config.decimals || 1,\n      // Set the decimal limit (default is 1)\n      unit = [\"\", \"K\", \"M\", \"B\", \"T\"],\n      // Number unit based exponent threshold\n      value = \"\"; // Define value variable\n\n    /** Changes base number and its unit for filesizing */\n    if (config.filesizing) {\n      baseNumber = 1024; // Use 1024 instead of 1000\n      unit = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]; // Change to 'bytes' unit\n    }\n\n    /** Set value based on the threshold */\n    for (var i = 4; i >= 0; i--) {\n      // If the exponent is 0\n      if (i === 0) value = \"\".concat(number.toFixed(limit), \" \").concat(unit[i]);\n      // If the exponent is above zero\n      if (number >= getFilesizeThreshold(baseNumber, i)) {\n        value = \"\".concat((number / getFilesizeThreshold(baseNumber, i)).toFixed(limit), \" \").concat(unit[i]);\n        break;\n      }\n    }\n\n    // Apply symbol before the value and return it as string\n    return symbol + value;\n  } else {\n    /** Return its value as float if not using filesizing or currency*/\n    return parseFloat(number);\n  }\n}\n\n/** This function will get the given base.  */\nfunction getFilesizeThreshold(baseNumber, index) {\n  return Math.pow(baseNumber, index);\n}\n\n/** This function is to get the last formated number */\nfunction applySeparator(value, config) {\n  // Get replaced value based on it's separator/symbol.\n  function replacedValue(val, separator) {\n    // Well this is my regExp for detecting the Thausands Separator\n    // I use 3 groups to determine it's separator\n    // THen the group 4 is to get the decimals value\n    var separatorRegExp =\n    // eslint-disable-next-line\n    /^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi;\n    return val.replace(separatorRegExp, function (match, g1, g2, g3, g4) {\n      // set initial result value\n      var result = \"\",\n        sep = \"\";\n      if (g1 !== undefined) {\n        // Group 1 is using comma as thausands separator, and period as decimal separator\n        result = g1.replace(new RegExp(/,/gi, \"gi\"), separator);\n        sep = \",\";\n      } else if (g2 !== undefined) {\n        // Group 2 is using period as thausands separator, and comma as decimal separator\n        result = g2.replace(new RegExp(/\\./gi, \"gi\"), separator);\n      } else if (g3 !== undefined) {\n        // Group 3 is using space as thausands separator, and comma as decimal separator\n        result = g3.replace(new RegExp(/ /gi, \"gi\"), separator);\n      }\n      if (g4 !== undefined) {\n        var decimal = sep !== \",\" ? separator !== \",\" ? \",\" : \".\" : \".\";\n        result += g4 !== undefined ? g4.replace(new RegExp(/\\.|,/gi, \"gi\"), decimal) : \"\";\n      }\n      // Returning result value;\n      return result;\n    });\n  }\n  // If config formater is not false, then apply separator\n  if (config.formater) {\n    // Now get the separator symbol\n    var symbol = config.separator // if config separator is setted\n    ? typeof config.separator === \"string\" // Check the type of value\n    ? config.separator // If it's type is string, then apply it's value\n    : \",\" // If it's not string (boolean), then apply comma as default separator\n    : \"\";\n    // Special exception when locale is not 'en-US' but separator value is 'true'\n    // Use it's default locale thausands separator.\n    if (config.formater !== \"en-US\" && config.separator === true) {\n      return value;\n    }\n    // Return the replaced Value based on it's symbol\n    return replacedValue(value, symbol);\n  }\n  // If config formater is false, then return it's default value\n  return value;\n}\n\n/** This function is to get formated number to be printed in the page */\nfunction formatNumber(number, config) {\n  // This is the configuration for 'toLocaleString' method\n  var strConfig = {\n    minimumFractionDigits: config.decimals,\n    maximumFractionDigits: config.decimals\n  };\n  // Get locale from config formater\n  var locale = typeof config.formater === \"string\" ? config.formater : undefined;\n\n  // Set and convert the number base on its config.\n  number = convertNumber(number, config);\n\n  // Now format the number to string base on it's locale\n  number = config.formater ? number.toLocaleString(locale, strConfig) : parseInt(number).toString();\n\n  // Last, apply the number separator using number as string\n  return applySeparator(number, config);\n}\n\n/** This function is to get the parsed value */\nfunction parseValue(data) {\n  // If number with dot (.), will be parsed as float\n  if (/^[0-9]+\\.[0-9]+$/.test(data)) {\n    return parseFloat(data);\n  }\n  // If just number, will be parsed as integer\n  if (/^[0-9]+$/.test(data)) {\n    return parseInt(data);\n  }\n  // If it's boolean string, will be parsed as boolean\n  if (/^true|false/i.test(data)) {\n    return /^true/i.test(data);\n  }\n  // Return it's value as default\n  return data;\n}\n\n// This function is to detect the element is in view or not.\nfunction elementIsInView(element) {\n  var top = element.offsetTop;\n  var left = element.offsetLeft;\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  while (element.offsetParent) {\n    element = element.offsetParent;\n    top += element.offsetTop;\n    left += element.offsetLeft;\n  }\n  return top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;\n}\n\n/** Just some condition to check browser Intersection Support */\nfunction intersectionListenerSupported() {\n  return \"IntersectionObserver\" in window && \"IntersectionObserverEntry\" in window && \"intersectionRatio\" in window.IntersectionObserverEntry.prototype;\n}\n\n/** Initialize PureCounter */\nfunction PureCounter() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var configs = {\n    start: 0,\n    // Starting number [uint]\n    end: 100,\n    // End number [uint]\n    duration: 2000,\n    // Count duration [milisecond]\n    delay: 10,\n    // Count delay [milisecond]\n    once: true,\n    // Counting at once or recount when scroll [boolean]\n    pulse: false,\n    // Pulse count for certain time [boolean|milisecond]\n    decimals: 0,\n    // Decimal places [uint]\n    legacy: true,\n    // If this is true it will use the scroll event listener on browsers\n    filesizing: false,\n    // Is it for filesize?\n    currency: false,\n    // Is it for currency? Use it for set the symbol too [boolean|char|string]\n    separator: false,\n    // Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\n    formater: \"us-US\",\n    // Number toLocaleString locale/formater, by default is \"en-US\" [string|boolean:false]\n    selector: \".purecounter\" // HTML query selector for spesific element\n  };\n\n  var configOptions = setOptions(options, configs);\n  function registerEventListeners() {\n    /** Get all elements with class 'purecounter' */\n    var elements = document.querySelectorAll(configOptions.selector);\n    /** Return if no elements */\n    if (elements.length === 0) {\n      return;\n    }\n\n    /** Run animateElements base on Intersection Support */\n    if (intersectionListenerSupported()) {\n      var intersectObserver = new IntersectionObserver(animateElements.bind(this), {\n        root: null,\n        rootMargin: \"20px\",\n        threshold: 0.5\n      });\n      elements.forEach(function (element) {\n        intersectObserver.observe(element);\n      });\n    } else {\n      if (window.addEventListener) {\n        animateLegacy(elements);\n        window.addEventListener(\"scroll\", function (e) {\n          animateLegacy(elements);\n        }, {\n          passive: true\n        });\n      }\n    }\n  }\n\n  /** This legacy to make Purecounter use very lightweight & fast */\n  function animateLegacy(elements) {\n    elements.forEach(function (element) {\n      var config = parseConfig(element);\n      if (config.legacy === true && elementIsInView(element)) {\n        animateElements([element]);\n      }\n    });\n  }\n\n  /** Main Element Count Animation */\n  function animateElements(elements, observer) {\n    elements.forEach(function (element) {\n      var elm = element.target || element; // Just make sure which element will be used\n      var elementConfig = parseConfig(elm); // Get config value on that element\n\n      // If duration is less than or equal zero, just format the 'end' value\n      if (elementConfig.duration <= 0) {\n        return elm.innerHTML = formatNumber(elementConfig.end, elementConfig) + \"+\";\n      }\n      if (!observer && !elementIsInView(element) || observer && element.intersectionRatio < 0.5) {\n        var value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n        return elm.innerHTML = formatNumber(value, elementConfig);\n      }\n\n      // If duration is more than 0, then start the counter\n      setTimeout(function () {\n        return startCounter(elm, elementConfig);\n      }, elementConfig.delay);\n    });\n  }\n\n  /** This function is to generate the element Config */\n  function parseConfig(element) {\n    // First, we need to declare the base Config\n    // This config will be used if the element doesn't have config\n    var baseConfig = configOptions;\n\n    // Next, get all 'data-precounter-*' attributes value. Store to array\n    var configValues = [].filter.call(element.attributes, function (attr) {\n      return /^data-purecounter-/.test(attr.name);\n    });\n\n    // Now, we create element config as an object\n    var elementConfig = configValues.length !== 0 ? Object.assign.apply(Object, [{}].concat(_toConsumableArray(configValues.map(function (_ref) {\n      var name = _ref.name,\n        value = _ref.value;\n      var key = name.replace(\"data-purecounter-\", \"\").toLowerCase(),\n        val = parseValue(value);\n      return _defineProperty({}, key, val);\n    })))) : {};\n\n    // Last setOptions and return\n    return setOptions(elementConfig, baseConfig);\n  }\n\n  /** Run the initial function */\n  registerEventListeners();\n}\nexport default PureCounter;","map":{"version":3,"names":["setOptions","config","baseConfig","newConfig","key","hasOwnProperty","val","parseValue","match","Object","assign","startCounter","element","incrementsPerStep","end","start","duration","delay","countMode","currentCount","innerHTML","formatNumber","once","setAttribute","counterWorker","setInterval","nextNum","nextNumber","pulse","setTimeout","clearInterval","number","steps","mode","parseFloat","convertNumber","filesizing","currency","Math","abs","Number","baseNumber","symbol","limit","decimals","unit","value","i","toFixed","getFilesizeThreshold","index","pow","applySeparator","replacedValue","separator","separatorRegExp","replace","g1","g2","g3","g4","result","sep","undefined","RegExp","decimal","formater","strConfig","minimumFractionDigits","maximumFractionDigits","locale","toLocaleString","parseInt","toString","data","test","elementIsInView","top","offsetTop","left","offsetLeft","width","offsetWidth","height","offsetHeight","offsetParent","window","pageYOffset","pageXOffset","innerHeight","innerWidth","intersectionListenerSupported","IntersectionObserverEntry","prototype","PureCounter","options","configs","legacy","selector","configOptions","registerEventListeners","elements","document","querySelectorAll","length","intersectObserver","IntersectionObserver","animateElements","bind","root","rootMargin","threshold","forEach","observe","addEventListener","animateLegacy","e","passive","parseConfig","observer","elm","target","elementConfig","intersectionRatio","configValues","filter","call","attributes","attr","name","map","toLowerCase"],"sources":["C:/Users/Mr O/Desktop/devspace/AJP/src/static/vendors/purecounterjs-1.5.0/js/purecounter_vanilla.js"],"sourcesContent":["/** This function is for create and merge configuration */\r\nfunction setOptions(config, baseConfig = {}) {\r\n    // Create new Config object;\r\n    var newConfig = {};\r\n\r\n    // Loop config items to set it value into newConfig\r\n    for (var key in config) {\r\n        // if baseConfig is set, only accept the baseconfig property\r\n        if (baseConfig !== {} && !baseConfig.hasOwnProperty(key)) continue;\r\n        // parse the config value\r\n        var val = parseValue(config[key]);\r\n        // set the newConfig property value\r\n        newConfig[key] = val;\r\n        // Exclusive for 'duration' or 'pulse' property, recheck the value\r\n        // If it's not a boolean, just set it to milisecond unit\r\n        if (key.match(/duration|pulse/)) {\r\n            newConfig[key] = typeof val != \"boolean\" ? val * 1000 : val;\r\n        }\r\n    }\r\n\r\n    // Finally, we can just merge the baseConfig (if any), with newConfig.\r\n    return Object.assign({}, baseConfig, newConfig);\r\n}\r\n\r\n/** This is the the counter method */\r\nfunction startCounter(element, config) {\r\n    // First, get the increments step\r\n    var incrementsPerStep =\r\n        (config.end - config.start) / (config.duration / config.delay);\r\n    // Next, set the counter mode (Increment or Decrement)\r\n    var countMode = \"inc\";\r\n\r\n    // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\r\n    if (config.start > config.end) {\r\n        countMode = \"dec\";\r\n        incrementsPerStep *= -1;\r\n    }\r\n\r\n    // Next, determine the starting value\r\n    var currentCount = parseValue(config.start);\r\n    // And then print it's value to the page\r\n    element.innerHTML = formatNumber(currentCount, config);\r\n\r\n    // If the config 'once' is true, then set the 'duration' to 0\r\n    if (config.once === true) {\r\n        element.setAttribute(\"data-purecounter-duration\", 0);\r\n    }\r\n\r\n    // Now, start counting with counterWorker using Interval method based on delay\r\n    var counterWorker = setInterval(() => {\r\n        // First, determine the next value base on current value, increment value, and count mode\r\n        var nextNum = nextNumber(currentCount, incrementsPerStep, countMode);\r\n        // Next, print that value to the page\r\n        element.innerHTML = formatNumber(nextNum, config);\r\n        // Now set that value to the current value, because it's already printed\r\n        currentCount = nextNum;\r\n\r\n        // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\r\n        if (\r\n            (currentCount >= config.end && countMode === \"inc\") ||\r\n            (currentCount <= config.end && countMode === \"dec\")\r\n        ) {\r\n            element.innerHTML = formatNumber(config.end, config) + \"+\";\r\n            // If 'pulse' is set ignore the 'once' config\r\n            if (config.pulse) {\r\n                // First set the 'duration' to zero\r\n                element.setAttribute(\"data-purecounter-duration\", 0);\r\n                // Next, use timeout to reset it duration back based on 'pulse' config\r\n                setTimeout(() => {\r\n                    element.setAttribute(\r\n                        \"data-purecounter-duration\",\r\n                        config.duration / 1000\r\n                    );\r\n                }, config.pulse);\r\n            }\r\n            clearInterval(counterWorker);\r\n        }\r\n    }, config.delay);\r\n}\r\n\r\n/** This function is to get the next number */\r\nfunction nextNumber(number, steps, mode = \"inc\") {\r\n    // First, get the exact value from the number and step (int or float)\r\n    number = parseValue(number);\r\n    steps = parseValue(steps);\r\n\r\n    // Last, get the next number based on current number, increment step, and count mode\r\n    // Always return it as float\r\n    return parseFloat(mode === \"inc\" ? number + steps : number - steps);\r\n}\r\n\r\n/** This function is to convert number into currency format */\r\nfunction convertNumber(number, config) {\r\n    /** Use converter if filesizing or currency is on */\r\n    if (config.filesizing || config.currency) {\r\n        number = Math.abs(Number(number)); // Get the absolute value of number\r\n\r\n        var baseNumber = 1000, // Base multiplying treshold\r\n            symbol =\r\n                config.currency && typeof config.currency === \"string\"\r\n                    ? config.currency\r\n                    : \"\", // Set the Currency Symbol (if any)\r\n            limit = config.decimals || 1, // Set the decimal limit (default is 1)\r\n            unit = [\"\", \"K\", \"M\", \"B\", \"T\"], // Number unit based exponent threshold\r\n            value = \"\"; // Define value variable\r\n\r\n        /** Changes base number and its unit for filesizing */\r\n        if (config.filesizing) {\r\n            baseNumber = 1024; // Use 1024 instead of 1000\r\n            unit = [\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"]; // Change to 'bytes' unit\r\n        }\r\n\r\n        /** Set value based on the threshold */\r\n        for (var i = 4; i >= 0; i--) {\r\n            // If the exponent is 0\r\n            if (i === 0) value = `${number.toFixed(limit)} ${unit[i]}`;\r\n            // If the exponent is above zero\r\n            if (number >= getFilesizeThreshold(baseNumber, i)) {\r\n                value = `${(number / getFilesizeThreshold(baseNumber, i)).toFixed(\r\n                    limit\r\n                )} ${unit[i]}`;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Apply symbol before the value and return it as string\r\n        return symbol + value;\r\n    } else {\r\n        /** Return its value as float if not using filesizing or currency*/\r\n        return parseFloat(number);\r\n    }\r\n}\r\n\r\n/** This function will get the given base.  */\r\nfunction getFilesizeThreshold(baseNumber, index) {\r\n    return Math.pow(baseNumber, index);\r\n}\r\n\r\n/** This function is to get the last formated number */\r\nfunction applySeparator(value, config) {\r\n    // Get replaced value based on it's separator/symbol.\r\n    function replacedValue(val, separator) {\r\n        // Well this is my regExp for detecting the Thausands Separator\r\n        // I use 3 groups to determine it's separator\r\n        // THen the group 4 is to get the decimals value\r\n        var separatorRegExp =\r\n            // eslint-disable-next-line\r\n            /^(?:(\\d{1,3},(?:\\d{1,3},?)*)|(\\d{1,3}\\.(?:\\d{1,3}\\.?)*)|(\\d{1,3}(?:\\s\\d{1,3})*))([\\.,]?\\d{0,2}?)$/gi;\r\n\r\n        return val.replace(separatorRegExp, function (match, g1, g2, g3, g4) {\r\n            // set initial result value\r\n            var result = \"\",\r\n                sep = \"\";\r\n            if (g1 !== undefined) {\r\n                // Group 1 is using comma as thausands separator, and period as decimal separator\r\n                result = g1.replace(new RegExp(/,/gi, \"gi\"), separator);\r\n                sep = \",\";\r\n            } else if (g2 !== undefined) {\r\n                // Group 2 is using period as thausands separator, and comma as decimal separator\r\n                result = g2.replace(new RegExp(/\\./gi, \"gi\"), separator);\r\n            } else if (g3 !== undefined) {\r\n                // Group 3 is using space as thausands separator, and comma as decimal separator\r\n                result = g3.replace(new RegExp(/ /gi, \"gi\"), separator);\r\n            }\r\n            if (g4 !== undefined) {\r\n                var decimal = sep !== \",\" ? (separator !== \",\" ? \",\" : \".\") : \".\";\r\n                result +=\r\n                    g4 !== undefined\r\n                        ? g4.replace(new RegExp(/\\.|,/gi, \"gi\"), decimal)\r\n                        : \"\";\r\n            }\r\n            // Returning result value;\r\n            return result;\r\n        });\r\n    }\r\n    // If config formater is not false, then apply separator\r\n    if (config.formater) {\r\n        // Now get the separator symbol\r\n        var symbol = config.separator // if config separator is setted\r\n            ? typeof config.separator === \"string\" // Check the type of value\r\n                ? config.separator // If it's type is string, then apply it's value\r\n                : \",\" // If it's not string (boolean), then apply comma as default separator\r\n            : \"\";\r\n        // Special exception when locale is not 'en-US' but separator value is 'true'\r\n        // Use it's default locale thausands separator.\r\n        if (config.formater !== \"en-US\" && config.separator === true) {\r\n            return value;\r\n        }\r\n        // Return the replaced Value based on it's symbol\r\n        return replacedValue(value, symbol);\r\n    }\r\n    // If config formater is false, then return it's default value\r\n    return value;\r\n}\r\n\r\n/** This function is to get formated number to be printed in the page */\r\nfunction formatNumber(number, config) {\r\n    // This is the configuration for 'toLocaleString' method\r\n    var strConfig = {\r\n        minimumFractionDigits: config.decimals,\r\n        maximumFractionDigits: config.decimals,\r\n    };\r\n    // Get locale from config formater\r\n    var locale = typeof config.formater === \"string\" ? config.formater : undefined;\r\n\r\n    // Set and convert the number base on its config.\r\n    number = convertNumber(number, config);\r\n\r\n    // Now format the number to string base on it's locale\r\n    number = config.formater\r\n        ? number.toLocaleString(locale, strConfig)\r\n        : parseInt(number).toString();\r\n\r\n    // Last, apply the number separator using number as string\r\n    return applySeparator(number, config);\r\n}\r\n\r\n/** This function is to get the parsed value */\r\nfunction parseValue(data) {\r\n    // If number with dot (.), will be parsed as float\r\n    if (/^[0-9]+\\.[0-9]+$/.test(data)) {\r\n        return parseFloat(data);\r\n    }\r\n    // If just number, will be parsed as integer\r\n    if (/^[0-9]+$/.test(data)) {\r\n        return parseInt(data);\r\n    }\r\n    // If it's boolean string, will be parsed as boolean\r\n    if (/^true|false/i.test(data)) {\r\n        return /^true/i.test(data);\r\n    }\r\n    // Return it's value as default\r\n    return data;\r\n}\r\n\r\n// This function is to detect the element is in view or not.\r\nfunction elementIsInView(element) {\r\n    var top = element.offsetTop;\r\n    var left = element.offsetLeft;\r\n    var width = element.offsetWidth;\r\n    var height = element.offsetHeight;\r\n\r\n    while (element.offsetParent) {\r\n        element = element.offsetParent;\r\n        top += element.offsetTop;\r\n        left += element.offsetLeft;\r\n    }\r\n\r\n    return (\r\n        top >= window.pageYOffset &&\r\n        left >= window.pageXOffset &&\r\n        top + height <= window.pageYOffset + window.innerHeight &&\r\n        left + width <= window.pageXOffset + window.innerWidth\r\n    );\r\n}\r\n\r\n/** Just some condition to check browser Intersection Support */\r\nfunction intersectionListenerSupported() {\r\n    return (\r\n        \"IntersectionObserver\" in window &&\r\n        \"IntersectionObserverEntry\" in window &&\r\n        \"intersectionRatio\" in window.IntersectionObserverEntry.prototype\r\n    );\r\n}\r\n\r\n/** Initialize PureCounter */\r\nfunction PureCounter(options = {}) {\r\n    var configs = {\r\n        start: 0, // Starting number [uint]\r\n        end: 100, // End number [uint]\r\n        duration: 2000, // Count duration [milisecond]\r\n        delay: 10, // Count delay [milisecond]\r\n        once: true, // Counting at once or recount when scroll [boolean]\r\n        pulse: false, // Pulse count for certain time [boolean|milisecond]\r\n        decimals: 0, // Decimal places [uint]\r\n        legacy: true, // If this is true it will use the scroll event listener on browsers\r\n        filesizing: false, // Is it for filesize?\r\n        currency: false, // Is it for currency? Use it for set the symbol too [boolean|char|string]\r\n        separator: false, // Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\r\n        formater: \"us-US\", // Number toLocaleString locale/formater, by default is \"en-US\" [string|boolean:false]\r\n        selector: \".purecounter\", // HTML query selector for spesific element\r\n    };\r\n    var configOptions = setOptions(options, configs);\r\n\r\n    function registerEventListeners() {\r\n        /** Get all elements with class 'purecounter' */\r\n        var elements = document.querySelectorAll(configOptions.selector);\r\n        /** Return if no elements */\r\n        if (elements.length === 0) {\r\n            return;\r\n        }\r\n\r\n        /** Run animateElements base on Intersection Support */\r\n        if (intersectionListenerSupported()) {\r\n            var intersectObserver = new IntersectionObserver(animateElements.bind(this), {\r\n                root: null,\r\n                rootMargin: \"20px\",\r\n                threshold: 0.5,\r\n            });\r\n\r\n            elements.forEach((element) => {\r\n                intersectObserver.observe(element);\r\n            });\r\n        } else {\r\n            if (window.addEventListener) {\r\n                animateLegacy(elements);\r\n                window.addEventListener(\r\n                    \"scroll\",\r\n                    function (e) {\r\n                        animateLegacy(elements);\r\n                    },\r\n                    { passive: true }\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /** This legacy to make Purecounter use very lightweight & fast */\r\n    function animateLegacy(elements) {\r\n        elements.forEach((element) => {\r\n            var config = parseConfig(element);\r\n            if (config.legacy === true && elementIsInView(element)) {\r\n                animateElements([element]);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Main Element Count Animation */\r\n    function animateElements(elements, observer) {\r\n        elements.forEach((element) => {\r\n            var elm = element.target || element; // Just make sure which element will be used\r\n            var elementConfig = parseConfig(elm); // Get config value on that element\r\n\r\n            // If duration is less than or equal zero, just format the 'end' value\r\n            if (elementConfig.duration <= 0) {\r\n                return (elm.innerHTML = formatNumber(elementConfig.end, elementConfig) + \"+\");\r\n            }\r\n\r\n            if (\r\n                (!observer && !elementIsInView(element)) ||\r\n                (observer && element.intersectionRatio < 0.5)\r\n            ) {\r\n                var value =\r\n                    elementConfig.start > elementConfig.end\r\n                        ? elementConfig.end\r\n                        : elementConfig.start;\r\n                return (elm.innerHTML = formatNumber(value, elementConfig));\r\n            }\r\n\r\n            // If duration is more than 0, then start the counter\r\n            setTimeout(() => {\r\n                return startCounter(elm, elementConfig);\r\n            }, elementConfig.delay);\r\n        });\r\n    }\r\n\r\n    /** This function is to generate the element Config */\r\n    function parseConfig(element) {\r\n        // First, we need to declare the base Config\r\n        // This config will be used if the element doesn't have config\r\n        var baseConfig = configOptions;\r\n\r\n        // Next, get all 'data-precounter-*' attributes value. Store to array\r\n        var configValues = [].filter.call(element.attributes, function (attr) {\r\n            return /^data-purecounter-/.test(attr.name);\r\n        });\r\n\r\n        // Now, we create element config as an object\r\n        var elementConfig =\r\n            configValues.length !== 0\r\n                ? Object.assign(\r\n                      {},\r\n                      ...configValues.map(({ name, value }) => {\r\n                          var key = name.replace(\"data-purecounter-\", \"\").toLowerCase(),\r\n                              val = parseValue(value);\r\n\r\n                          return { [key]: val };\r\n                      })\r\n                  )\r\n                : {};\r\n\r\n        // Last setOptions and return\r\n        return setOptions(elementConfig, baseConfig);\r\n    }\r\n\r\n    /** Run the initial function */\r\n    registerEventListeners();\r\n}\r\n\r\n\r\nexport default PureCounter;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}